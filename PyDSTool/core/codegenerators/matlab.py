#!/usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import absolute_import

from PyDSTool.common import intersect, concatStrDict, idfn
from PyDSTool.parseUtils import convertPowers, addArgToCalls
from PyDSTool.Symbolic import QuantSpec

from .base import _processReused, CodeGenerator


class Matlab(CodeGenerator):

    def generate_aux(self):
        auxnames = self.fspec.auxfns.keys()
        auxfns = {}
        # parameter and variable definitions

        # sorted version of var and par names sorted version of par
        # names (vars not #define'd in aux functions unless Jacobian)
        vnames = self.fspec.vars
        pnames = self.fspec.pars
        vnames.sort()
        pnames.sort()

        for auxname in auxnames:
            assert auxname not in ['auxvars', 'vfield'], \
                ("auxiliary function name '" + auxname + "' clashes with internal"
                 " names")
        # must add parameter argument so that we can name
        # pars inside the functions! this would either
        # require all calls to include this argument (yuk!) or
        # else we add these extra pars automatically to
        # every call found in the .c code (as is done currently.
        # this is still an untidy solution, but there you go...)
        for auxname, auxspec in self.fspec._auxfnspecs.iteritems():
            assert len(auxspec) == 2, 'auxspec tuple must be of length 2'
            if not isinstance(auxspec[0], list):
                print "Found type ", type(auxspec[0])
                print "Containing: ", auxspec[0]
                raise TypeError('aux function arguments '
                                'must be given as a list')
            if not isinstance(auxspec[1], str):
                print "Found type ", type(auxspec[1])
                print "Containing: ", auxspec[1]
                raise TypeError('aux function specification '
                                'must be a string of the function code')
            # assert auxspec[1].find('^') == -1, ('carat character ^ is not '
            #                                 'permitted in function definitions'
            #                                 '-- use pow(x,p) syntax instead')
            # Process Jacobian functions specially, if present
            if auxname == 'Jacobian':
                raise NotImplementedError
            elif auxname == 'Jacobian_pars':
                raise NotImplementedError
            elif auxname == 'massMatrix':
                raise NotImplementedError
            else:
                ismat = False
                topstr = "function y_ = " + auxname + "("
                commentstr = "% Auxilliary function " + auxname + " for model " + \
                    self.fspec.name + \
                    "\n% Generated by PyDSTool for ADMC++ target\n\n"
                parlist = ""
                namemap = {}
                for parname in auxspec[0]:
                    parlist += parname + "__, "
                    namemap[parname] = parname + '__'
                topstr += parlist + " p_)\n"
                sig = topstr + commentstr
                pardefines = self._prepareMatlabPDefines(pnames)
                auxstr = auxspec[1]
                if any([pt in auxstr for pt in ('pow', '**')]):
                    auxstr = convertPowers(auxstr, '^')
                reusestr, auxspec_processedDict = self._processReusedMatlab(
                    [auxname],
                    {auxname: auxstr.replace(' ', '').replace('\n', '')})
                # addition of parameter done in Generator code

            dummyQ = QuantSpec('dummy', auxspec_processedDict[auxname],
                               treatMultiRefs=False, preserveSpace=True)
            if not ismat:
                dummyQ.mapNames(namemap)
            body_processed = "y_ = " * (not ismat) + dummyQ() + ";\n\n"
            # auxspecstr = sig + " {\n\n" + pardefines + vardefines*ismat \
            auxspecstr = sig + pardefines + " \n\n" \
                + "\n" + (len(reusestr) > 0) * "% reused term definitions \n" \
                + reusestr + (len(reusestr) > 0) * "\n" + body_processed
            # sig as second entry, whereas Python-coded specifications
            # have the fn name there
            auxfns[auxname] = (auxspecstr, sig)
        self.fspec._protected_auxnames.extend(auxnames)
        # Don't apply #define's for built-in functions
        return auxfns

    def generate_spec(self):
        assert self.fspec.targetlang == 'matlab', ('Wrong target language for this'
                                              ' call')
        assert self.fspec.varspecs != {}, 'varspecs attribute must be defined'
        specnames_unsorted = self.fspec.varspecs.keys()
        specname_vars = intersect(self.fspec.vars, specnames_unsorted)
        specname_vars.sort()
        # parameter and variable definitions
        # sorted version of var and par names
        vnames = specname_vars
        pnames = self.fspec.pars
        pnames.sort()
        pardefines = self._prepareMatlabPDefines(pnames)
        vardefines = self._prepareMatlabVDefines(vnames)
        # produce vector field specification
        assert self.fspec.vars == specname_vars, ('Mismatch between declared '
                                             ' variable names and varspecs keys')
        valid_depTargNames = self.fspec.inputs + self.fspec.vars + self.fspec.auxvars
        for specname, specstr in self.fspec.varspecs.iteritems():
            assert type(
                specstr) == str, "Specification for %s was not a string" % specname
            if any([pt in specstr for pt in ('pow', '**')]):
                specstr = convertPowers(specstr, '^')
            specQS = QuantSpec('__spectemp__', specstr)
            for s in specQS:
                if s in valid_depTargNames and (specname, s) not in \
                        self.fspec.dependencies:  # and specname != s:
                    self.fspec.dependencies.append((specname, s))
        # pre-process reused sub-expression dictionary to adapt for
        # known calling sequence in Matlab
        reusestr, specupdated = self._processReusedMatlab(specname_vars,
                                                          self.fspec.varspecs)
        self.fspec.varspecs.update(specupdated)
        specstr_Matlab = self._genSpecFnMatlab(
            'vfield', reusestr, specname_vars,
            pardefines, vardefines, True)
        self.fspec.spec = specstr_Matlab
        # do not produce auxiliary variables specification

    def _prepareMatlabPDefines(self, pnames):
        pardefines = ""
        for i in xrange(len(pnames)):
            p = pnames[i]
            pardefines += "\t" + p + " = p_(" + str(i + 1) + ");\n"

        alldefines = "\n% Parameter definitions\n\n" + pardefines
        return alldefines

    def _prepareMatlabVDefines(self, vnames):
        vardefines = ""
        for i in xrange(len(vnames)):
            v = vnames[i]
            vardefines += "\t" + v + " = x_(" + str(i + 1) + ");\n"
        alldefines = "\n% Variable definitions\n\n" + vardefines
        return alldefines

    def _genSpecFnMatlab(self, funcname, reusestr, specnames, pardefines,
            vardefines, docodeinserts):
        topstr = "function [vf_, y_] = " + funcname + "(vf_, t_, x_, p_)\n"
        commentstr = "% Vector field definition for model " + \
            self.fspec.name + "\n% Generated by PyDSTool for ADMC++ target\n\n"

        specstr = topstr + commentstr + pardefines + vardefines + "\n"
        if docodeinserts and self.opts['start']:
            specstr += self._format_user_code(self.opts['start'])
        specstr += (len(reusestr) > 0) * "% reused term definitions \n" \
            + reusestr + "\n"
        # add function body
        for i in xrange(len(specnames)):
            xname = specnames[i]
            fbody = self.fspec.varspecs[xname]
            fbody_parsed = self._processIfMatlab(fbody)
            if self.fspec.auxfns:
                fbody_parsed = addArgToCalls(fbody_parsed,
                                             self.fspec.auxfns.keys(),
                                             "p_")
               # if 'initcond' in self.fspec.auxfns:
                    # convert 'initcond(x)' to 'initcond("x")' for
                    # compatibility with C syntax
                #    fbody_parsed = wrapArgInCall(fbody_parsed,
                 #                   'initcond', '"')
            specstr += "y_(" + str(i + 1) + ") = " + fbody_parsed + ";\n\n"
        if docodeinserts and self.opts['end']:
            specstr += self._format_user_code(self.opts['end'])
        specstr += "\n"
        return (specstr, funcname)

    def _processIfMatlab(self, specStr):
        # NEED TO CHECK WHETHER THIS IS NECESSARY AND WORKS
        # IF STATEMENTS LOOK DIFFERENT IN MATLAB
        qspec = QuantSpec('spec', specStr)
        qtoks = qspec[:]
        if 'if' in qtoks:
            raise NotImplementedError
        else:
            new_specStr = specStr
        return new_specStr

    def _processReusedMatlab(self, specnames, specdict):
        """Process reused subexpression terms for Matlab code."""

        if self.fspec.auxfns:
            def addParToCall(s):
                return addArgToCalls(s, self.fspec.auxfns.keys(), "p_")
            parseFunc = addParToCall
        else:
            parseFunc = idfn
        reused, specupdated, new_protected, order = _processReused(specnames,
                                                                   specdict,
                                                                   self.fspec.reuseterms,
                                                                   '', '', ';',
                                                                   parseFunc)
        self.fspec._protected_reusenames = new_protected
        reusedefs = {}.fromkeys(new_protected)
        for _, deflist in reused.iteritems():
            for d in deflist:
                reusedefs[d[2]] = d
        return (concatStrDict(reusedefs, intersect(order, reusedefs.keys())),
                specupdated)

    def _format_user_code(self, code):
        before = '% Verbose code insert -- begin '
        after =  '% Verbose code insert -- end \n\n'
        return self._format_code(code, before, after)
